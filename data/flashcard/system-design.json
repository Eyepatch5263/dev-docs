[
    {
        "id": "system-design-1",
        "question": "What is horizontal vs vertical scaling?",
        "answer": "Vertical scaling: add more power to existing server (CPU, RAM), limited by hardware, single point of failure, simpler. Horizontal scaling: add more servers, unlimited scaling, fault tolerant, complex (load balancing, data distribution). Horizontal preferred for large-scale systems.",
        "category": "system-design"
    },
    {
        "id": "system-design-2",
        "question": "Explain the concept of caching and its strategies.",
        "answer": "Caching stores frequently accessed data in fast storage. Strategies: Cache-aside (app manages), Write-through (write to cache and DB), Write-back (write to cache, async to DB), Read-through (cache loads on miss). Eviction: LRU, LFU, FIFO. Levels: browser, CDN, application, database.",
        "category": "system-design"
    },
    {
        "id": "system-design-3",
        "question": "What is eventual consistency vs strong consistency?",
        "answer": "Strong consistency: reads always return latest write, slower, lower availability (ACID databases). Eventual consistency: reads may return stale data temporarily, faster, higher availability, eventually converges (NoSQL). Trade-off between consistency and availability (CAP theorem).",
        "category": "system-design"
    },
    {
        "id": "system-design-4",
        "question": "Explain the concept of a message queue and when to use it.",
        "answer": "Message queue enables asynchronous communication between services. Producer sends messages, consumer processes them. Benefits: decoupling, load leveling, fault tolerance, scalability. Use cases: task processing, event-driven architecture, microservices. Examples: RabbitMQ, Kafka, SQS.",
        "category": "system-design"
    },
    {
        "id": "system-design-5",
        "question": "What is database partitioning/sharding?",
        "answer": "Partitioning splits data across multiple databases. Horizontal (sharding): split rows by key (user ID). Vertical: split columns by table. Benefits: scalability, performance, fault isolation. Challenges: cross-shard queries, rebalancing, complexity. Sharding key crucial for even distribution.",
        "category": "system-design"
    },
    {
        "id": "system-design-6",
        "question": "Explain the concept of idempotency in APIs.",
        "answer": "Idempotent operation produces same result regardless of how many times executed. GET, PUT, DELETE are idempotent. POST is not. Important for: retry logic, network failures, distributed systems. Implementation: unique request IDs, database constraints, conditional updates.",
        "category": "system-design"
    },
    {
        "id": "system-design-7",
        "question": "What is a reverse proxy and its benefits?",
        "answer": "Reverse proxy sits between clients and servers, forwarding requests. Benefits: load balancing, SSL termination, caching, compression, security (hide backend), DDoS protection. Examples: Nginx, HAProxy, AWS ALB. Different from forward proxy (client-side).",
        "category": "system-design"
    },
    {
        "id": "system-design-8",
        "question": "Explain the concept of rate limiting.",
        "answer": "Rate limiting controls request frequency per user/IP. Algorithms: Token Bucket (burst allowed), Leaky Bucket (smooth rate), Fixed Window (simple, burst at boundaries), Sliding Window (accurate, complex). Benefits: prevent abuse, ensure fair usage, protect resources. Implement at API gateway or application level.",
        "category": "system-design"
    },
    {
        "id": "system-design-9",
        "question": "What is the difference between monolithic and microservices architecture?",
        "answer": "Monolithic: single codebase, tightly coupled, simple deployment, scales as unit, single tech stack. Microservices: independent services, loosely coupled, complex deployment, scales independently, polyglot. Microservices better for large teams, complex domains. Monolith simpler for small apps.",
        "category": "system-design"
    },
    {
        "id": "system-design-10",
        "question": "Explain the concept of circuit breaker pattern.",
        "answer": "Circuit breaker prevents cascading failures by stopping requests to failing service. States: Closed (normal), Open (failing, reject requests), Half-Open (test recovery). After threshold failures, opens circuit. After timeout, tries half-open. Prevents resource exhaustion, enables graceful degradation.",
        "category": "system-design"
    },
    {
        "id": "system-design-11",
        "question": "What is database replication and its types?",
        "answer": "Replication copies data across multiple databases. Master-Slave: one write, multiple reads, simple, read scaling. Master-Master: multiple writes, complex conflict resolution. Synchronous: wait for replicas, consistent, slower. Asynchronous: don't wait, faster, eventual consistency. Use for availability and read scaling.",
        "category": "system-design"
    },
    {
        "id": "system-design-12",
        "question": "Explain the concept of API gateway.",
        "answer": "API gateway is single entry point for all client requests. Functions: routing, authentication, rate limiting, caching, request/response transformation, monitoring. Benefits: centralized logic, security, simplified clients, versioning. Examples: Kong, AWS API Gateway, Azure API Management.",
        "category": "system-design"
    },
    {
        "id": "system-design-13",
        "question": "What is the difference between synchronous and asynchronous communication?",
        "answer": "Synchronous: caller waits for response, blocking, simpler, tight coupling (HTTP, RPC). Asynchronous: caller doesn't wait, non-blocking, complex, loose coupling (message queues, events). Async better for: long operations, high throughput, fault tolerance. Sync simpler for immediate responses.",
        "category": "system-design"
    },
    {
        "id": "system-design-14",
        "question": "Explain the concept of database indexing.",
        "answer": "Index is data structure improving query speed. B-tree (default, range queries), Hash (equality), Full-text (text search). Trade-offs: faster reads, slower writes, more storage. Index on: frequently queried columns, foreign keys, WHERE/JOIN columns. Avoid over-indexing.",
        "category": "system-design"
    },
    {
        "id": "system-design-15",
        "question": "What is the Saga pattern in distributed transactions?",
        "answer": "Saga manages distributed transactions as sequence of local transactions. Each step has compensating transaction for rollback. Types: Choreography (event-driven), Orchestration (central coordinator). Use when: ACID not possible, long-running transactions. Provides eventual consistency.",
        "category": "system-design"
    },
    {
        "id": "system-design-16",
        "question": "Explain the concept of service discovery.",
        "answer": "Service discovery enables services to find each other dynamically. Client-side: client queries registry (Consul, Eureka). Server-side: load balancer queries registry. Benefits: dynamic scaling, fault tolerance, no hardcoded IPs. Essential for microservices, cloud environments.",
        "category": "system-design"
    },
    {
        "id": "system-design-17",
        "question": "What is the difference between SQL and NoSQL databases in system design?",
        "answer": "SQL: structured schema, ACID, vertical scaling, complex queries, relationships (PostgreSQL, MySQL). NoSQL: flexible schema, BASE, horizontal scaling, simple queries, denormalized (MongoDB, Cassandra). Choose SQL for: complex transactions, relationships. NoSQL for: scale, flexibility, high throughput.",
        "category": "system-design"
    },
    {
        "id": "system-design-18",
        "question": "Explain the concept of blue-green deployment.",
        "answer": "Blue-green maintains two identical environments. Blue (current), Green (new version). Deploy to green, test, switch traffic. Benefits: zero downtime, instant rollback, reduced risk. Requires: 2x infrastructure, database compatibility. Alternative: canary deployment (gradual rollout).",
        "category": "system-design"
    },
    {
        "id": "system-design-19",
        "question": "What is the difference between stateful and stateless services?",
        "answer": "Stateless: no session data stored, each request independent, easy to scale, load balance anywhere (REST APIs). Stateful: maintains session data, complex scaling, sticky sessions needed (WebSockets, game servers). Stateless preferred for: scalability, fault tolerance. Stateful for: real-time, persistent connections.",
        "category": "system-design"
    },
    {
        "id": "system-design-20",
        "question": "Explain the concept of event-driven architecture.",
        "answer": "Event-driven: services communicate via events (state changes). Producer emits events, consumers react. Benefits: loose coupling, scalability, real-time processing, audit trail. Patterns: pub/sub, event sourcing, CQRS. Use for: microservices, real-time systems, complex workflows. Examples: Kafka, EventBridge.",
        "category": "system-design"
    }
]