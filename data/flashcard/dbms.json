[
    {
        "id": "dbms-1",
        "question": "What is the difference between SQL and NoSQL databases?",
        "answer": "SQL databases are relational, use structured schemas, support ACID transactions, and scale vertically (e.g., PostgreSQL, MySQL). NoSQL databases are non-relational, schema-flexible, support eventual consistency, and scale horizontally (e.g., MongoDB, Cassandra, Redis).",
        "category": "dbms"
    },
    {
        "id": "dbms-2",
        "question": "Explain ACID properties in databases.",
        "answer": "Atomicity: transactions are all-or-nothing. Consistency: data remains valid after transactions. Isolation: concurrent transactions don't interfere. Durability: committed data persists even after system failures. ACID ensures reliable transaction processing.",
        "category": "dbms"
    },
    {
        "id": "dbms-3",
        "question": "What is database normalization and why is it important?",
        "answer": "Normalization organizes data to reduce redundancy and improve integrity. Forms: 1NF (atomic values), 2NF (no partial dependencies), 3NF (no transitive dependencies), BCNF (stricter 3NF). Benefits: less storage, easier updates, fewer anomalies. Trade-off: may require more joins.",
        "category": "dbms"
    },
    {
        "id": "dbms-4",
        "question": "What is the difference between clustered and non-clustered indexes?",
        "answer": "Clustered index determines physical order of data rows (one per table), faster for range queries. Non-clustered index creates separate structure with pointers to data (multiple per table), faster for specific lookups. Clustered = dictionary, non-clustered = book index.",
        "category": "dbms"
    },
    {
        "id": "dbms-5",
        "question": "Explain the CAP theorem.",
        "answer": "CAP states distributed systems can only guarantee 2 of 3: Consistency (all nodes see same data), Availability (system always responds), Partition tolerance (works despite network failures). CP systems (MongoDB), AP systems (Cassandra), CA impossible in distributed systems.",
        "category": "dbms"
    },
    {
        "id": "dbms-6",
        "question": "What is a database transaction and how does it work?",
        "answer": "A transaction is a logical unit of work with multiple operations treated as single unit. Uses BEGIN, COMMIT (save changes), ROLLBACK (undo changes). Ensures ACID properties. Example: bank transfer debits one account and credits another atomically.",
        "category": "dbms"
    },
    {
        "id": "dbms-7",
        "question": "What are database isolation levels?",
        "answer": "Read Uncommitted: dirty reads possible. Read Committed: only committed data visible. Repeatable Read: same query returns same results. Serializable: full isolation, no anomalies. Higher isolation = more consistency but less concurrency. Trade-off between consistency and performance.",
        "category": "dbms"
    },
    {
        "id": "dbms-8",
        "question": "Explain database sharding and when to use it.",
        "answer": "Sharding horizontally partitions data across multiple databases/servers. Each shard contains subset of data. Benefits: horizontal scaling, improved performance, fault isolation. Challenges: complex queries across shards, rebalancing. Use when: vertical scaling insufficient, data too large for single server.",
        "category": "dbms"
    },
    {
        "id": "dbms-9",
        "question": "What is the difference between DELETE, TRUNCATE, and DROP?",
        "answer": "DELETE removes rows based on condition, can be rolled back, triggers fire, slower. TRUNCATE removes all rows, faster, can't be rolled back (in most DBs), resets identity. DROP removes entire table structure and data, can't be rolled back.",
        "category": "dbms"
    },
    {
        "id": "dbms-10",
        "question": "What is a deadlock and how can you prevent it?",
        "answer": "Deadlock occurs when two+ transactions wait for each other's locks indefinitely. Prevention: lock ordering (acquire locks in same order), timeouts, deadlock detection and rollback. Avoidance: shorter transactions, appropriate isolation levels, optimistic locking.",
        "category": "dbms"
    },
    {
        "id": "dbms-11",
        "question": "Explain the difference between INNER JOIN, LEFT JOIN, and RIGHT JOIN.",
        "answer": "INNER JOIN returns only matching rows from both tables. LEFT JOIN returns all rows from left table plus matches from right (nulls if no match). RIGHT JOIN returns all rows from right table plus matches from left. FULL OUTER JOIN returns all rows from both.",
        "category": "dbms"
    },
    {
        "id": "dbms-12",
        "question": "What is database replication and what are its types?",
        "answer": "Replication copies data across multiple databases for availability and performance. Master-Slave: one write node, multiple read replicas. Master-Master: multiple write nodes, conflict resolution needed. Synchronous: wait for replica confirmation. Asynchronous: don't wait, eventual consistency.",
        "category": "dbms"
    },
    {
        "id": "dbms-13",
        "question": "What is the N+1 query problem and how do you solve it?",
        "answer": "N+1 problem: fetching N items requires 1 query + N additional queries for related data. Solution: eager loading (JOIN or IN clause), batch loading, caching, GraphQL DataLoader. Example: loading users then querying each user's posts separately.",
        "category": "dbms"
    },
    {
        "id": "dbms-14",
        "question": "Explain optimistic vs pessimistic locking.",
        "answer": "Optimistic locking assumes conflicts are rare, checks version/timestamp before commit, retries on conflict. Pessimistic locking acquires locks immediately, blocks other transactions. Optimistic = better concurrency, more retries. Pessimistic = guaranteed success, less concurrency. Choose based on conflict frequency.",
        "category": "dbms"
    },
    {
        "id": "dbms-15",
        "question": "What is a database view and when should you use it?",
        "answer": "A view is a virtual table based on a SQL query, doesn't store data. Benefits: simplify complex queries, security (hide columns), abstraction layer. Materialized views store results for performance. Use for: frequently used complex queries, row-level security, backward compatibility.",
        "category": "dbms"
    },
    {
        "id": "dbms-16",
        "question": "What is database denormalization and when is it appropriate?",
        "answer": "Denormalization intentionally adds redundancy to improve read performance by reducing joins. Trade-offs: faster reads, slower writes, more storage, potential inconsistency. Appropriate for: read-heavy workloads, reporting databases, data warehouses, when performance critical.",
        "category": "dbms"
    },
    {
        "id": "dbms-17",
        "question": "Explain the difference between OLTP and OLAP databases.",
        "answer": "OLTP (Online Transaction Processing): handles real-time transactions, normalized, row-oriented, fast writes, supports ACID (e.g., MySQL, PostgreSQL). OLAP (Online Analytical Processing): handles complex queries, denormalized, column-oriented, fast reads, aggregations (e.g., Snowflake, BigQuery).",
        "category": "dbms"
    },
    {
        "id": "dbms-18",
        "question": "What is a foreign key and why is it important?",
        "answer": "Foreign key is a column referencing primary key in another table, enforcing referential integrity. Ensures related data exists, prevents orphaned records. Actions: CASCADE (propagate changes), SET NULL, RESTRICT. Important for: data consistency, relationship enforcement, query optimization.",
        "category": "dbms"
    },
    {
        "id": "dbms-19",
        "question": "What is database connection pooling?",
        "answer": "Connection pooling maintains a cache of database connections for reuse instead of creating new connections per request. Benefits: reduced overhead, faster response times, controlled resource usage. Configuration: min/max connections, timeout, idle timeout. Essential for high-traffic applications.",
        "category": "dbms"
    },
    {
        "id": "dbms-20",
        "question": "Explain the difference between WHERE and HAVING clauses.",
        "answer": "WHERE filters rows before grouping, works on individual rows, can't use aggregate functions. HAVING filters groups after GROUP BY, works on aggregated data, can use aggregate functions. Example: WHERE filters users, HAVING filters groups like 'departments with >10 employees'.",
        "category": "dbms"
    }
]